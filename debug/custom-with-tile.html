<!DOCTYPE html>
<html lang="en">
    <head>
        <title>MapLibre GL JS debug page</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../dist/maplibre-gl.css" />
        <style>
            body {
                margin: 0;
                padding: 0;
            }
            html,
            body,
            #map {
                height: 100%;
            }
        </style>
    </head>

    <body>
        <div id="map"></div>

        <script src="../dist/maplibre-gl-dev.js"></script>
        <script src="https://unpkg.com/three@0.106.2/build/three.min.js"></script>
        <script>
            const modelOrigin = [0, 0];
            const modelAltitude = 1000000;
            const modelRotate = [Math.PI / 2, 0, 0];

            const modelAsMercatorCoordinate =
                maplibregl.MercatorCoordinate.fromLngLat(
                    modelOrigin,
                    modelAltitude,
                );
            const modelTransform = {
                translateX: modelAsMercatorCoordinate.x,
                translateY: modelAsMercatorCoordinate.y,
                translateZ: modelAsMercatorCoordinate.z,
                rotateX: modelRotate[0],
                rotateY: modelRotate[1],
                rotateZ: modelRotate[2],
                /* Since our 3D model is in real world meters, a scale transform needs to be
                 * applied since the CustomLayerInterface expects units in MercatorCoordinates.
                 */
                scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits(),
            };
            const map = (window.map = new maplibregl.Map({
                container: 'map',
                zoom: 1.69,
                center: [-9.4, -26.8],
                bearing: 131,
                pitch: 60,
                style: {
                    version: 8,
                    sources: {
                        gsi: {
                            type: 'raster',
                            tiles: [
                                'https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg',
                            ],
                            attribution:
                                '<a href="https://maps.gsi.go.jp/development/ichiran.html">Geospatial Information Authority of Japan</a>',
                        },
                    },
                    layers: [],
                },
                hash: true,
            }));

            class CustomRasterTile {
                constructor() {
                    this.id = 'custom-rastertile';
                    this.type = 'custom';
                    this.renderingMode = '3d';
                    this.source = 'gsi';
                    this.minzoom = 2;
                    this.maxzoom = 5;
                }

                onAdd(map, gl) {
                    this.map = map;

                    this.camera = new THREE.Camera();
                    this.scene = new THREE.Scene();
                    // use the MapLibre GL JS map canvas for three.js
                    this.renderer = new THREE.WebGLRenderer({
                        canvas: map.getCanvas(),
                        context: gl,
                        antialias: true,
                    });

                    this.renderer.autoClear = false;

                    const geometry = new THREE.BufferGeometry();
                    const vertices = new Float32Array([
                        -1000000.0, -1000000.0, 1000000.0, 1000000.0,
                        -1000000.0, 1000000.0, 1000000.0, 1000000.0, 1000000.0,
                    ]);
                    const uvs = new Float32Array([
                        0.0, 0.0, 0.0, 1.0, 1.0, 1.0,
                    ]);
                    geometry.addAttribute(
                        'position',
                        new THREE.BufferAttribute(vertices, 3),
                    );
                    geometry.addAttribute(
                        'uv',
                        new THREE.BufferAttribute(uvs, 2),
                    );
                    const material = new THREE.MeshBasicMaterial();
                    this.triangle = new THREE.Mesh(geometry, this.material);
                    this.scene.add(this.triangle);

                    const boxGeom = new THREE.BoxGeometry(
                        1000000,
                        1000000,
                        1000000,
                    );
                    const boxMaterial = new THREE.MeshBasicMaterial();
                    this.box = new THREE.Mesh(boxGeom, boxMaterial);
                    this.scene.add(this.box);
                }

                render(gl, matrix, tiles) {
                    // WebGLTexture -> THREE.texture
                    const threetexture = new THREE.Texture();
                    const texProps = this.renderer.properties.get(threetexture);
                    texProps.__webglTexture = tiles[0].texture.texture;
                    const material = new THREE.MeshBasicMaterial({
                        map: threetexture,
                        side: THREE.DoubleSide,
                    });
                    this.triangle.material = material;

                    // WebGLTexture -> THREE.texture
                    const boxTexs = [
                        new THREE.Texture(),
                        new THREE.Texture(),
                        new THREE.Texture(),
                        new THREE.Texture(),
                        new THREE.Texture(),
                        new THREE.Texture(),
                    ];
                    boxTexs.forEach((tex, idx) => {
                        const boxTexProps = this.renderer.properties.get(tex);
                        boxTexProps.__webglTexture = tiles[idx].texture.texture;
                    });
                    const boxMaterial = boxTexs.map((tex) => {
                        return new THREE.MeshBasicMaterial({
                            map: tex,
                            side: THREE.DoubleSide,
                        });
                    });
                    this.box.material = boxMaterial;

                    const rotationX = new THREE.Matrix4().makeRotationAxis(
                        new THREE.Vector3(1, 0, 0),
                        modelTransform.rotateX,
                    );
                    const rotationY = new THREE.Matrix4().makeRotationAxis(
                        new THREE.Vector3(0, 1, 0),
                        modelTransform.rotateY,
                    );
                    const rotationZ = new THREE.Matrix4().makeRotationAxis(
                        new THREE.Vector3(0, 0, 1),
                        modelTransform.rotateZ,
                    );

                    const m = new THREE.Matrix4().fromArray(matrix);
                    const l = new THREE.Matrix4()
                        .makeTranslation(
                            modelTransform.translateX,
                            modelTransform.translateY,
                            modelTransform.translateZ,
                        )
                        .scale(
                            new THREE.Vector3(
                                modelTransform.scale,
                                -modelTransform.scale,
                                modelTransform.scale,
                            ),
                        )
                        .multiply(rotationX)
                        .multiply(rotationY)
                        .multiply(rotationZ);

                    this.camera.projectionMatrix = m.multiply(l);
                    this.renderer.state.reset();
                    this.renderer.render(this.scene, this.camera);
                    this.map.triggerRepaint();
                }
            }

            map.on('load', function () {
                map.addLayer(new CustomRasterTile());
            });
        </script>
    </body>
</html>
