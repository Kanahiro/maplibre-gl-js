<!DOCTYPE html>
<html lang="en">
    <head>
        <title>MapLibre GL JS debug page</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../dist/maplibre-gl.css" />
        <style>
            body {
                margin: 0;
                padding: 0;
            }
            html,
            body,
            #map {
                height: 100%;
            }
        </style>
    </head>

    <body>
        <div id="map"></div>

        <script src="../dist/maplibre-gl-dev.js"></script>
        <script src="https://unpkg.com/three@0.106.2/build/three.min.js"></script>
        <script>
            const modelOrigin = [0, 0];
            const modelAltitude = 1000000;
            const modelRotate = [Math.PI / 2, 0, 0];

            const modelAsMercatorCoordinate =
                maplibregl.MercatorCoordinate.fromLngLat(
                    modelOrigin,
                    modelAltitude,
                );
            const modelTransform = {
                translateX: modelAsMercatorCoordinate.x,
                translateY: modelAsMercatorCoordinate.y,
                translateZ: modelAsMercatorCoordinate.z,
                rotateX: modelRotate[0],
                rotateY: modelRotate[1],
                rotateZ: modelRotate[2],
                /* Since our 3D model is in real world meters, a scale transform needs to be
                 * applied since the CustomLayerInterface expects units in MercatorCoordinates.
                 */
                scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits(),
            };
            const map = (window.map = new maplibregl.Map({
                container: 'map',
                zoom: 4,
                center: [0, 0],
                style: {
                    version: 8,
                    sources: {
                        gsi: {
                            type: 'raster',
                            tiles: [
                                'https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg',
                            ],
                            attribution:
                                '<a href="https://maps.gsi.go.jp/development/ichiran.html">Geospatial Information Authority of Japan</a>',
                        },
                    },
                    layers: [],
                },
                hash: true,
            }));
            class TileSource {
                constructor() {
                    this.id = 'tile-source';
                    this.type = 'custom';
                    this.renderingMode = '3d';
                    this.source = 'gsi';
                    this.minzoom = 2;
                    this.maxzoom = 5;
                }

                onAdd(map, gl) {
                    const vertexSource = `

                    attribute vec3 aPos;
                    attribute vec2 aTexCoord;
                    uniform mat4 uMatrix;
                    varying vec2 vTexCoord;

                    void main() {
                        vTexCoord = aTexCoord;
                        gl_Position = uMatrix * vec4(aPos, 1.0);
                    }
                    `;

                    const fragmentSource = `
                    uniform sampler2D uTexture;
                    varying vec2 vTexCoord;
                    void main() {
                        vec4 smpColor = texture2D(uTexture, vTexCoord);
                        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
                    }
                    `;

                    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                    gl.shaderSource(vertexShader, vertexSource);
                    gl.compileShader(vertexShader);
                    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                    gl.shaderSource(fragmentShader, fragmentSource);
                    gl.compileShader(fragmentShader);

                    this.program = gl.createProgram();
                    gl.attachShader(this.program, vertexShader);
                    gl.attachShader(this.program, fragmentShader);
                    gl.linkProgram(this.program);
                    gl.validateProgram(this.program);

                    this.program.aPos = gl.getAttribLocation(
                        this.program,
                        'aPos',
                    );
                    this.program.uMatrix = gl.getUniformLocation(
                        this.program,
                        'uMatrix',
                    );
                    this.program.uTexture = gl.getUniformLocation(
                        this.program,
                        'uTexture',
                    );
                    this.program.aTexCoord = gl.getAttribLocation(
                        this.program,
                        'aTexCoord',
                    );

                    const x = 0.5 - 0.015;
                    const y = 0.5 - 0.01;
                    const z = 0.01;
                    const d = 0.01;

                    const vertexArray = new Float32Array([
                        0.5, 0.5, 0, 0.51, 0.5, 0, 0.5, 0.51, 0,
                    ]);
                    const indexArray = new Uint16Array([0, 1, 2]);
                    const texCoordArray = new Float32Array([
                        0.0,
                        0.0,
                        1.0,
                        0.0,
                        ,
                        0.0,
                        1.0,
                    ]);

                    this.vertexBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);

                    this.indexBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                    gl.bufferData(
                        gl.ELEMENT_ARRAY_BUFFER,
                        indexArray,
                        gl.STATIC_DRAW,
                    );

                    this.texCoordBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
                    gl.bufferData(
                        gl.ARRAY_BUFFER,
                        texCoordArray,
                        gl.STATIC_DRAW,
                    );

                    // bind vertex
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                    gl.enableVertexAttribArray(this.program.a_pos);
                    gl.vertexAttribPointer(
                        this.program.aPos,
                        3,
                        gl.FLOAT,
                        false,
                        0,
                        0,
                    );

                    // bind texCoord
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
                    gl.enableVertexAttribArray(this.program.a_texCoord);
                    gl.vertexAttribPointer(
                        this.program.aTexCoord,
                        2,
                        gl.FLOAT,
                        false,
                        0,
                        0,
                    );
                }

                render(gl, matrix, tiles) {
                    if (tiles.length === 0) return;
                    console.log(tiles);
                    gl.useProgram(this.program);

                    // bind texture
                    const { texture } = tiles[0];
                    gl.bindTexture(gl.TEXTURE_2D, texture.texture);
                    gl.uniform1i(this.program.uTexture, 0);

                    gl.uniformMatrix4fv(this.program.uMatrix, false, matrix);

                    gl.drawElements(gl.TRIANGLES, 3, gl.UNSIGNED_SHORT, 0);
                }
            }

            map.on('load', function () {
                map.addLayer(new TileSource());
            });
        </script>
    </body>
</html>
